import os

Import("env")
Import("env_modules")
env_module = env_modules.Clone()

rust_target_arch=''
rust_target_os=''
if env['arch']=="arm64":
    rust_target_arch = "aarch64"
elif env['arch']=="x86_64":
    rust_target_arch = "x86_64"
else:
    raise Exception(f"unsupported arch {env['arch']}")

if env['platform']=="linuxbsd":
    rust_target_os = "unknown-linux-gnu"
elif env['platform']=="android":
    rust_target_os = "linux-android"
elif env['platform']=="windows":
    rust_target_os="pc-windows-msvc"
else:
    raise Exception(f"unsupported platform {env['platform']}")

target = f"{rust_target_arch}-{rust_target_os}"

# build rust crates
cargo_cmd = ""

if env.get('use_asan'):
    cargo_cmd+="RUSTFLAGS=\"-Z sanitizer=address\" "

if target == "aarch64-linux-android":
    cargo_cmd += "cargo ndk -t arm64-v8a b -p rust_lib"
else:
    cargo_cmd += f"cargo b -p rust_lib --target {target}"

if not env.dev_build:
    cargo_cmd += " -r"

assert os.system(cargo_cmd) == 0

# generate bindings
rust_libs = ["gd_glicol", "gd_jmespath", "gd_json_converter"]

try:os.mkdir("cxxbridge")
except:pass

for p in rust_libs:
    assert os.system(f"cxxbridge crates/{p}/src/lib.rs --header > ./cxxbridge/{p}.rs.h") == 0
    assert os.system(f"cxxbridge crates/{p}/src/lib.rs > ./cxxbridge/{p}.rs.cpp") == 0

# generate cxx.h
assert os.system(f"cxxbridge --header > ./cxxbridge/cxx.h") == 0


module_obj = []
env_module.add_source_files(module_obj, "*.cpp")
if env.editor_build:
    env_module.add_source_files(module_obj, "editor/*.cpp")

cxxbridge_obj = []
env_cxxbridge=env_module.Clone()
env_cxxbridge.disable_warnings()
env_cxxbridge.add_source_files(cxxbridge_obj, "cxxbridge/*.cpp")

lib_path = [f"target/{target}/{'release' if not env.dev_build else 'debug'}"]
env.Append(LIBPATH=[env.Dir(p).abspath for p in lib_path])

if env['platform']=="windows":
    env.Append(LIBSUFFIXES=[".lib"])
env.Append(LIBS=["rust_lib"])

env.modules_sources += module_obj
env.modules_sources += cxxbridge_obj
